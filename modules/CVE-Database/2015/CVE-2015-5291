{Modified: 2016-12-07T13:16:21.097000, Published: 2015-11-02T14:59:05.123000, access: {authentication: NONE, complexity: MEDIUM, vector: NETWORK}, capec: [{id: 10, name: Buffer Overflow via Environment Variables, prerequisites: The application uses environment variables.
An environment variable exposed to the user is vulnerable to a buffer overflow.
The vulnerable environment variable uses untrusted data.
Tainted data used in the environment variables is not properly validated. For instance boundary checking is not done before copying the input data to a buffer., related_weakness: [120, 302, 118, 119, 74, 99, 20, 680, 733, 697], solutions: Do not expose environment variable to the user.
Do not use untrusted data in your environment variables.
Use a language or compiler that performs automatic bounds checking
There are tools such as Sharefuzz [R.10.3] which is an environment variable fuzzer for Unix that support loading a shared library. You can use Sharefuzz to determine if you are exposing an environment variable vulnerable to buffer overflow., summary: This attack pattern involves causing a buffer overflow through manipulation of environment variables. Once the attacker finds that they can modify an environment variable, they may try to overflow associated buffers. This attack leverages implicit trust often placed in environment variables.}, {id: 100, name: Overflow Buffers, prerequisites: Targeted software performs buffer operations.
Targeted software inadequately performs bounds-checking on buffer operations.
Attacker has the capability to influence the input to buffer operations., related_weakness: [120, 119, 131, 129, 805, 19, 680], solutions: Use a language or compiler that performs automatic bounds checking.
Use secure functions not vulnerable to buffer overflow.
If you have to use dangerous functions, make sure that you do boundary checking.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Use OS-level preventative functionality. Not a complete solution.
Utilize static source code analysis tools to identify potential buffer overflow weaknesses in the software., summary: Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an attacker. As a consequence, an attacker is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the attackers' choice.}, {id: 14, name: Client-side Injection-induced Buffer Overflow, prerequisites: The targeted client software communicates with an external server.
The targeted client software has a buffer overflow vulnerability., related_weakness: [120, 353, 118, 119, 74, 20, 680, 697, 713], solutions: The client software should not install untrusted code from a non-authenticated server.
The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers.
Perform input validation for length of buffer inputs.
Use a language or compiler that performs automatic bounds checking.
Use an abstraction library to abstract away risky APIs. Not a complete solution.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Ensure all buffer uses are consistently bounds-checked.
Use OS-level preventative functionality. Not a complete solution., summary: This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.}, {id: 24, name: Filter Failure through Buffer Overflow, prerequisites: Ability to control the length of data passed to an active filter., related_weakness: [120, 119, 118, 74, 20, 680, 733, 697], solutions: Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.
Pre-design: Use a language or compiler that performs automatic bounds checking.
Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Operational: Use OS-level preventative functionality. Not a complete solution.
Design: Use an abstraction library to abstract away risky APIs. Not a complete solution., summary: In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. the user input is let into the system unfiltered).}, {id: 42, name: MIME Conversion, prerequisites: The target system uses a mail server.
Mail server vendor has not released a patch for the MIME conversion routine, the patch itself has a security hole or does not fix the original problem, or the patch has not been applied to the user's system., related_weakness: [120, 119, 74, 20], solutions: Stay up to date with third party vendor patches
From "Exploiting Software", please see reference below.
Use the sendmail restricted shell program (smrsh)
Use mail.local, summary: An attacker exploits a weakness in the MIME conversion routine to cause a buffer overflow and gain control over the mail server machine. The MIME system is designed to allow various different information formats to be interpreted and sent via e-mail. Attack points exist when data are converted to MIME compatible format and back.}, {id: 44, name: Overflow Binary Resource File, prerequisites: Target software processes binary resource files.
Target software contains a buffer overflow vulnerability reachable through input from a user-controllable binary resource file., related_weakness: [120, 119, 697, 713], solutions: Perform appropriate bounds checking on all buffers.
Design: Enforce principle of least privilege
Design: Static code analysis
Implementation: Execute program in less trusted process space environment, do not allow lower integrity processes to write to higher integrity processes
Implementation: Keep software patched to ensure that known vulnerabilities are not available for attackers to target on host., summary: An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the attacker access to the execution stack and execute arbitrary code in the target process. This attack pattern is a variant of standard buffer overflow attacks using an unexpected vector (binary files) to wrap its attack and open up a new attack vector. The attacker is required to either directly serve the binary content to the victim, or place it in a locale like a MP3 sharing application, for the victim to download. The attacker then is notified upon the download or otherwise locates the vulnerability opened up by the buffer overflow.}, {id: 45, name: Buffer Overflow via Symbolic Links, prerequisites: The attacker can create symbolic link on the target host.
The target host does not perform correct boundary checking while consuming data from a resources., related_weakness: [120, 285, 302, 118, 119, 74, 20, 680, 697], solutions: Pay attention to the fact that the resource you read from can be a replaced by a Symbolic link. You can do a Symlink check before reading the file and decide that this is not a legitimate way of accessing the resource.
Because Symlink can be modified by an attacker, make sure that the ones you read are located in protected directories.
Pay attention to the resource pointed to by your symlink links (See attack pattern named "Forced Symlink race"), they can be replaced by malicious resources.
Always check the size of the input data before copying to a buffer.
Use a language or compiler that performs automatic bounds checking.
Use an abstraction library to abstract away risky APIs. Not a complete solution.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Use OS-level preventative functionality. Not a complete solution., summary: This type of attack leverages the use of symbolic links to cause buffer overflows. An attacker can try to create or manipulate a symbolic link file such that its contents result in out of bounds data. When the target software processes the symbolic link file, it could potentially overflow internal buffers with insufficient bounds checking.}, {id: 46, name: Overflow Variables and Tags, prerequisites: The target program consumes user-controllable data in the form of tags or variables.
The target program does not perform sufficient boundary checking., related_weakness: [120, 118, 119, 74, 20, 680, 733, 697], solutions: Use a language or compiler that performs automatic bounds checking.
Use an abstraction library to abstract away risky APIs. Not a complete solution.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Use OS-level preventative functionality. Not a complete solution.
Do not trust input data from user. Validate all user input., summary: This type of attack leverages the use of tags or variables from a formatted configuration data to cause buffer overflow. The attacker crafts a malicious HTML page or configuration file that includes oversized strings, thus causing an overflow.}, {id: 47, name: Buffer Overflow via Parameter Expansion, prerequisites: The program expands one of the parameters passed to a function with input controlled by the user, but a later function making use of the expanded parameter erroneously considers the original, not the expanded size of the parameter.
The expanded parameter is used in the context where buffer overflow may become possible due to the incorrect understanding of the parameter size (i.e. thinking that it is smaller than it really is)., related_weakness: [120, 119, 118, 130, 131, 74, 20, 680, 697], solutions: Ensure that when parameter expansion happens in the code that the assumptions used to determine the resulting size of the parameter are accurate and that the new size of the parameter is visible to the whole system, summary: In this attack, the target software is given input that the attacker knows will be modified and expanded in size during processing. This attack relies on the target software failing to anticipate that the expanded data may exceed some internal limit, thereby creating a buffer overflow.}, {id: 8, name: Buffer Overflow in an API Call, prerequisites: The target host exposes an API to the user.
One or more API functions exposed by the target host has a buffer overflow vulnerability., related_weakness: [120, 119, 118, 74, 20, 680, 733, 697], solutions: Use a language or compiler that performs automatic bounds checking.
Use secure functions not vulnerable to buffer overflow.
If you have to use dangerous functions, make sure that you do boundary checking.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Use OS-level preventative functionality. Not a complete solution., summary: This attack targets libraries or shared code modules which are vulnerable to buffer overflow attacks. An attacker who has access to an API may try to embed malicious code in the API function call and exploit a buffer overflow vulnerability in the function's implementation. All clients that make use of the code library thus become vulnerable by association. This has a very broad effect on security across a system, usually affecting more than one software process.}, {id: 9, name: Buffer Overflow in Local Command-Line Utilities, prerequisites: The target host exposes a command-line utility to the user.
The command-line utility exposed by the target host has a buffer overflow vulnerability that can be exploited., related_weakness: [120, 118, 119, 74, 20, 680, 733, 697], solutions: Carefully review the service's implementation before making it available to user. For instance you can use manual or automated code review to uncover vulnerabilities such as buffer overflow.
Use a language or compiler that performs automatic bounds checking.
Use an abstraction library to abstract away risky APIs. Not a complete solution.
Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.
Operational: Use OS-level preventative functionality. Not a complete solution.
Apply the latest patches to your user exposed services. This may not be a complete solution, especially against a zero day attack.
Do not unnecessarily expose services., summary: This attack targets command-line utilities available in a number of shells. An attacker can leverage a vulnerability found in a command-line utility to escalate privilege to root.}], cvss: 6.8, cvss-time: 2015-11-03T14:59:01.337000, cwe: CWE-119, id: CVE-2015-5291, impact: {availability: PARTIAL, confidentiality: PARTIAL, integrity: PARTIAL}, last-modified: 2017-06-30T21:29:19.420000, nessus: [{NASL family: SuSE Local Security Checks, NASL id: OPENSUSE-2015-898.NASL, description: This update for mbedtls fixes the following security and non-security issues :

  - Update to 1.3.15

  - Fix potential double free if ssl_set_psk() is called     more than once and some allocation fails. Cannot be     forced remotely. Found by Guido Vranken, Intelworks.

  - Fix potential heap corruption on windows when     x509_crt_parse_path() is passed a path longer than 2GB.
    Cannot be triggered remotely. Found by Guido Vranken,     Intelworks.

  - Fix potential buffer overflow in some asn1_write_xxx()     functions. Cannot be triggered remotely unless you     create X.509 certificates based on untrusted input or     write keys of untrusted origin. Found by Guido Vranken,     Intelworks.

  - The x509 max_pathlen constraint was not enforced on     intermediate certificates. Found by Nicholas Wilson, fix     and tests provided by Janos Follath. #280 and #319

  - Self-signed certificates were not excluded from pathlen     counting, resulting in some valid X.509 being     incorrectly rejected. Found and fix provided by Janos     Follath. #319

  - Fix bug causing some handshakes to fail due to some     non-fatal alerts not begin properly ignored. Found by     mancha and Kasom Koht-arsa, #308

  - Fix build error with configurations where ecdhe-psk is     the only key exchange. Found and fix provided by Chris     Hammond. #270

  - Fix failures in mpi on sparc(64) due to use of bad     assembly code. Found by Kurt Danielson. #292

  - Fix typo in name of the extkeyusage oid. found by     inestlerode, #314

  - Fix bug in asn.1 encoding of booleans that caused     generated ca certificates to be rejected by some     applications, including OS X Keychain. Found and fixed     by Jonathan Leroy, Inikup.

  - Fix 'destination buffer is too small' error in     cert_write program. Found and fixed by Jonathan Leroy,     Inikup.

  - Update to 1.3.14

  - Added fix for CVE-2015-5291 (boo#949380) to prevent heap     corruption due to buffer overflow of the hostname or     session ticket. Found by Guido Vranken, Intelworks.

  - Fix stack-based buffer overflow in pkcs12 decryption     (used by mbedtls_pk_parse_key(file)() when the password     is > 129 bytes. Found by Guido Vranken, Intelworks. Not     triggerable remotely.

  - Fix potential buffer overflow in     mbedtls_mpi_read_string(). Found by Guido Vranken,     Intelworks. Not exploitable remotely in the context of     TLS, but might be in other uses. On 32 bit machines,     requires reading a string of close to or larger than 1GB     to exploit; on 64 bit machines, would require reading a     string of close to or larger than 2^62 bytes.

  - Fix potential random memory allocation in     mbedtls_pem_read_buffer() on crafted PEM input data.
    Found and fix provided by Guido Vranken, Intelworks. Not     triggerable remotely in TLS. Triggerable remotely if you     accept PEM data from an untrusted source.

  - Fix potential double-free if ssl_set_psk() is called     repeatedly on the same ssl_context object and some     memory allocations fail. Found by Guido Vranken,     Intelworks. Can not be forced remotely.

  - Fix possible heap buffer overflow in base64_encode()     when the input buffer is 512MB or larger on 32-bit     platforms. Found by Guido Vranken, Intelworks. Found by     Guido Vranken. Not trigerrable remotely in TLS.

  - Fix potential heap buffer overflow in servers that     perform client authentication against a crafted CA cert.
    Cannot be triggered remotely unless you allow third     parties to pick trust CAs for client auth. Found by     Guido Vranken, Intelworks.

  - Fix compile error in net.c with musl libc. found and     patch provided by zhasha (#278).

  - Fix macroization of 'inline' keywork when building as     c++. (#279)

  - Added checking of hostname length in ssl_set_hostname()     to ensure domain names are compliant with RFC 1035.

  - Changes for 1.3.13

  - Fix possible client-side NULL pointer dereference (read)     when the client tries to continue the handshake after it     failed (a misuse of the API). (Found and patch provided     by Fabian Foerg, Gotham Digital Science using afl-fuzz.)

  - Add countermeasure against lenstra's rsa-crt attack for     pkcs#1 v1.5 signatures. (Found by Florian Weimer, Red     Hat.)     https://securityblog.redhat.com/2015/09/02/factoring-rsa
    -keys-with-tls-perfect-forward-secrecy/

  - Setting ssl_min_dhm_bytes in config.h had no effect     (overriden in ssl.h) (found by Fabio Solari) (#256)

  - Fix bug in mbedtls_rsa_public() and     mbedtls_rsa_private() that could result trying to unlock     an unlocked mutex on invalid input (found by Fredrik     Axelsson) (#257)

  - Fix -wshadow warnings (found by hnrkp) (#240)

  - Fix unused function warning when using mbedtls_mdx_alt     or MBEDTLS_SHAxxx_ALT (found by Henrik) (#239)

  - Fix memory corruption in pkey programs (found by     yankuncheng) (#210)

  - Fix memory corruption on client with overlong psk     identity, around SSL_MAX_CONTENT_LEN or higher - not     triggerrable remotely (found by Aleksandrs Saveljevs)     (#238)

  - Fix off-by-one error in parsing supported point format     extension that caused some handshakes to fail.

  - When verifying a certificate chain, if an intermediate     certificate is trusted, no later cert is checked.
    (suggested by hannes-landeholm) (#220).

  - Changes for 1.3.12

  - Increase the minimum size of diffie-hellman parameters     accepted by the client to 1024 bits, to protect against     Logjam attack.

  - Increase the size of default diffie-hellman parameters     on the server to 2048 bits. This can be changed with     ssl_set_dh_params().

  - Fix thread-safety issue in ssl debug module (found by     edwin van vliet).

  - Some example programs were not built using make, not     included in visual Studio projects (found by Kristian     Bendiksen).

  - Fix build error with cmake and pre-4.5 versions of gcc     (found by hugo Leisink).

  - Fix missing -static-ligcc when building shared libraries     for windows with make.

  - Fix compile error with armcc5 --gnu.

  - Add ssl_min_dhm_bytes configuration parameter in     config.h to choose the minimum size of Diffie-Hellman     parameters accepted by the client.

  - The pem parser now accepts a trailing space at end of     lines (#226)., last seen: 2019-02-21, modified: 2015-12-16, plugin id: 87394, published: 2015-12-16, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=87394, title: openSUSE Security Update : mbedtls (openSUSE-2015-898)}, {NASL family: Debian Local Security Checks, NASL id: DEBIAN_DLA-331.NASL, description: A flaw was found in PolarSSl and mbed TLS :

When the client creates its ClientHello message, due to insufficient bounds checking it can overflow the heap-based buffer containing the message while writing some extensions. Two extensions in particular could be used by a remote attacker to trigger the overflow: the session ticket extension and the server name indication (SNI) extension.

Although most of the vulnerable code is not present in the Squeeze version, this upload contains at least a length check for incoming data.

NOTE: Tenable Network Security has extracted the preceding description block directly from the DLA security advisory. Tenable has attempted to automatically clean and format it as much as possible without introducing additional issues., last seen: 2019-02-21, modified: 2018-07-06, plugin id: 86552, published: 2015-10-23, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=86552, title: Debian DLA-331-1 : polarssl security update}, {NASL family: SuSE Local Security Checks, NASL id: OPENSUSE-2015-962.NASL, description: This update for polarssl fixes the following security issue :

  - CVE-2015-5291: Remote code execution via session tickets     or SNI (boo#949380), last seen: 2019-02-21, modified: 2015-12-29, plugin id: 87633, published: 2015-12-29, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=87633, title: openSUSE Security Update : polarssl (openSUSE-2015-962)}, {NASL family: Fedora Local Security Checks, NASL id: FEDORA_2015-30A417BEA9.NASL, description: - Update to 1.3.14 - CVE-2015-5291 Release notes:
    https://tls.mbed.org/tech-     updates/releases/mbedtls-2.1.2-and-1.3.14-and-polarssl-1     .2.17-released Security notes:
    https://tls.mbed.org/tech-updates/security-advisories/mb     edtls-security- advisory-2015-01

Note that Tenable Network Security has extracted the preceding description block directly from the Fedora security advisory. Tenable has attempted to automatically clean and format it as much as possible without introducing additional issues., last seen: 2019-02-21, modified: 2016-04-07, plugin id: 89196, published: 2016-03-04, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=89196, title: Fedora 21 : mbedtls-1.3.14-1.fc21 (2015-30a417bea9)}, {NASL family: FreeBSD Local Security Checks, NASL id: FREEBSD_PKG_07A1A76C734B11E5AE8114DAE9D210B8.NASL, description: ARM Limited reports :

When the client creates its ClientHello message, due to insufficient bounds checking it can overflow the heap-based buffer containing the message while writing some extensions. Two extensions in particular could be used by a remote attacker to trigger the overflow : the session ticket extension and the server name indication (SNI) extension., last seen: 2019-02-21, modified: 2018-11-10, plugin id: 86386, published: 2015-10-15, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=86386, title: FreeBSD : mbedTLS/PolarSSL -- DoS and possible remote code execution (07a1a76c-734b-11e5-ae81-14dae9d210b8)}, {NASL family: Gentoo Local Security Checks, NASL id: GENTOO_GLSA-201706-18.NASL, description: The remote host is affected by the vulnerability described in GLSA-201706-18 (mbed TLS: Multiple vulnerabilities)

    Multiple vulnerabilities have been discovered in mbed TLS. Please review       the CVE identifiers referenced below for details.
  Impact :

    A remote attacker could possibly execute arbitrary code with the       privileges of the process, or cause a Denial of Service condition.
  Workaround :

    There is no known workaround at this time., last seen: 2019-02-21, modified: 2018-01-26, plugin id: 100944, published: 2017-06-21, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=100944, title: GLSA-201706-18 : mbed TLS: Multiple vulnerabilities (SLOTH)}, {NASL family: Fedora Local Security Checks, NASL id: FEDORA_2015-7F939B3AF5.NASL, description: - Update to 1.3.14 - CVE-2015-5291 Release notes:
    https://tls.mbed.org/tech-     updates/releases/mbedtls-2.1.2-and-1.3.14-and-polarssl-1     .2.17-released Security notes:
    https://tls.mbed.org/tech-updates/security-advisories/mb     edtls-security- advisory-2015-01

Note that Tenable Network Security has extracted the preceding description block directly from the Fedora security advisory. Tenable has attempted to automatically clean and format it as much as possible without introducing additional issues., last seen: 2019-02-21, modified: 2016-03-04, plugin id: 89300, published: 2016-03-04, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=89300, title: Fedora 22 : mbedtls-1.3.14-1.fc22 (2015-7f939b3af5)}, {NASL family: Fedora Local Security Checks, NASL id: FEDORA_2015-E22BB33731.NASL, description: - Update to 2.1.2 - CVE-2015-5291 Release notes:
    https://tls.mbed.org/tech-     updates/releases/mbedtls-2.1.2-and-1.3.14-and-polarssl-1     .2.17-released Security notes:
    https://tls.mbed.org/tech-updates/security-advisories/mb     edtls-security- advisory-2015-01

Note that Tenable Network Security has extracted the preceding description block directly from the Fedora security advisory. Tenable has attempted to automatically clean and format it as much as possible without introducing additional issues., last seen: 2019-02-21, modified: 2016-03-04, plugin id: 89440, published: 2016-03-04, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=89440, title: Fedora 23 : mbedtls-2.1.2-1.fc23 (2015-e22bb33731)}, {NASL family: Debian Local Security Checks, NASL id: DEBIAN_DSA-3468.NASL, description: It was discovered that polarssl, a library providing SSL and TLS support, contained two heap-based buffer overflows that could allow a remote attacker to trigger denial of service (via application crash) or arbitrary code execution., last seen: 2019-02-21, modified: 2018-11-10, plugin id: 88602, published: 2016-02-08, reporter: Tenable, source: https://www.tenable.com/plugins/index.php?view=single&id=88602, title: Debian DSA-3468-1 : polarssl - security update}], ranking: [[{circl: 3}]], references: [http://lists.fedoraproject.org/pipermail/package-announce/2015-November/170317.html, http://lists.fedoraproject.org/pipermail/package-announce/2015-October/169625.html, http://lists.fedoraproject.org/pipermail/package-announce/2015-October/169765.html, http://lists.opensuse.org/opensuse-security-announce/2015-12/msg00013.html, http://lists.opensuse.org/opensuse-updates/2015-12/msg00119.html, http://www.debian.org/security/2016/dsa-3468, https://guidovranken.files.wordpress.com/2015/10/cve-2015-5291.pdf, https://guidovranken.wordpress.com/2015/10/07/cve-2015-5291/, https://security.gentoo.org/glsa/201706-18, https://tls.mbed.org/tech-updates/security-advisories/mbedtls-security-advisory-2015-01], refmap: {confirm: [https://tls.mbed.org/tech-updates/security-advisories/mbedtls-security-advisory-2015-01], debian: [DSA-3468], fedora: [FEDORA-2015-30a417bea9, FEDORA-2015-7f939b3af5, FEDORA-2015-e22bb33731], gentoo: [GLSA-201706-18], misc: [https://guidovranken.files.wordpress.com/2015/10/cve-2015-5291.pdf, https://guidovranken.wordpress.com/2015/10/07/cve-2015-5291/], suse: [openSUSE-SU-2015:2257, openSUSE-SU-2015:2371]}, summary: Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message.  NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0., vulnerable_configuration: [{id: cpe:2.3:a:polarssl:polarssl:1.2.16, title: cpe:2.3:a:polarssl:polarssl:1.2.16}, {id: cpe:2.3:a:arm:mbed_tls:1.3.13, title: ARM mbed TLS 1.3.13}, {id: cpe:2.3:a:arm:mbed_tls:2.1.1, title: ARM mbed TLS 2.1.1}], vulnerable_configuration_cpe_2_2: [cpe:/a:polarssl:polarssl:1.2.16, cpe:/a:arm:mbed_tls:1.3.13, cpe:/a:arm:mbed_tls:2.1.1]}
